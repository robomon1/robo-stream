// Stream-Pi Deck Desktop App

class StreamPiDeck {
    constructor() {
        this.config = null;
        this.currentView = 'deck';
        this.currentButton = null;
        this.scenes = [];
        this.inputs = [];
        this.currentStatus = null;
        this.buttonElements = new Map();
        this.editMode = false;
        this.selectedIcon = null;
        
        // Icon library organized by category
        this.iconLibrary = {
            streaming: [
                { name: 'video', label: 'Video' },
                { name: 'play', label: 'Play' },
                { name: 'pause', label: 'Pause' },
                { name: 'stop-circle', label: 'Stop' },
                { name: 'radio', label: 'Live' },
                { name: 'wifi', label: 'Streaming' },
                { name: 'cast', label: 'Cast' }
            ],
            recording: [
                { name: 'circle', label: 'Record' },
                { name: 'disc', label: 'Recording' },
                { name: 'save', label: 'Save' },
                { name: 'download', label: 'Download' }
            ],
            audio: [
                { name: 'mic', label: 'Mic' },
                { name: 'mic-off', label: 'Mic Off' },
                { name: 'volume-2', label: 'Volume' },
                { name: 'volume-x', label: 'Muted' },
                { name: 'headphones', label: 'Headphones' },
                { name: 'speaker', label: 'Speaker' }
            ],
            scenes: [
                { name: 'layout', label: 'Layout' },
                { name: 'layers', label: 'Layers' },
                { name: 'grid', label: 'Grid' },
                { name: 'maximize', label: 'Fullscreen' },
                { name: 'minimize', label: 'Minimize' },
                { name: 'square', label: 'Window' }
            ],
            media: [
                { name: 'skip-back', label: 'Previous' },
                { name: 'skip-forward', label: 'Next' },
                { name: 'repeat', label: 'Loop' },
                { name: 'shuffle', label: 'Shuffle' },
                { name: 'rewind', label: 'Rewind' },
                { name: 'fast-forward', label: 'Fast Forward' }
            ],
            camera: [
                { name: 'camera', label: 'Camera' },
                { name: 'camera-off', label: 'Camera Off' },
                { name: 'aperture', label: 'Lens' },
                { name: 'focus', label: 'Focus' }
            ],
            general: [
                { name: 'zap', label: 'Power' },
                { name: 'settings', label: 'Settings' },
                { name: 'info', label: 'Info' },
                { name: 'alert-circle', label: 'Alert' },
                { name: 'check-circle', label: 'Success' },
                { name: 'x-circle', label: 'Cancel' },
                { name: 'star', label: 'Favorite' },
                { name: 'heart', label: 'Like' },
                { name: 'bell', label: 'Bell' },
                { name: 'clock', label: 'Time' },
                { name: 'calendar', label: 'Calendar' },
                { name: 'image', label: 'Image' }
            ]
        };

        this.init();
    }

    async init() {
        // Wait for Wails runtime to be ready
        window.addEventListener('DOMContentLoaded', async () => {
            await this.loadConfig();
            this.renderDeck();
            this.setupEventListeners();
            await this.loadScenes();
            await this.loadInputs();
            await this.updateStatus();
            await this.loadServerURL();
            
            // Listen for status updates from backend
            window.runtime.EventsOn('status_update', (status) => {
                this.updateStatusDisplay(status);
            });

            // Start status polling
            setInterval(() => this.updateStatus(), 5000);
        });
    }

    async loadConfig() {
        try {
            this.config = await window.go.main.App.GetConfig();
        } catch (error) {
            console.error('Failed to load config:', error);
        }
    }

    async loadScenes() {
        try {
            this.scenes = await window.go.main.App.GetScenes();
            this.updateSceneDropdown();
        } catch (error) {
            console.error('Failed to load scenes:', error);
        }
    }

    async loadInputs() {
        try {
            this.inputs = await window.go.main.App.GetInputs();
            this.updateInputDropdown();
        } catch (error) {
            console.error('Failed to load inputs:', error);
        }
    }

    async loadServerURL() {
        try {
            const url = await window.go.main.App.GetServerURL();
            document.getElementById('server-url').value = url;
        } catch (error) {
            console.error('Failed to load server URL:', error);
        }
    }

    updateSceneDropdown() {
        const select = document.getElementById('scene-name');
        select.innerHTML = '<option value="">-- Select Scene --</option>';
        this.scenes.forEach(scene => {
            const option = document.createElement('option');
            option.value = scene;
            option.textContent = scene;
            select.appendChild(option);
        });
    }

    updateInputDropdown() {
        const select = document.getElementById('input-name');
        select.innerHTML = '<option value="">-- Select Input --</option>';
        this.inputs.forEach(input => {
            const option = document.createElement('option');
            option.value = input;
            option.textContent = input;
            select.appendChild(option);
        });
    }

    renderDeck() {
        const grid = document.getElementById('button-grid');
        grid.innerHTML = '';
        grid.style.gridTemplateColumns = `repeat(${this.config.grid.cols}, 80px)`;

        // Store button elements for state updates
        this.buttonElements = new Map();

        for (let row = 0; row < this.config.grid.rows; row++) {
            for (let col = 0; col < this.config.grid.cols; col++) {
                const buttonId = `btn-${row}-${col}`;
                const button = this.config.buttons.find(b => b.id === buttonId);

                const btnElement = document.createElement('button');
                btnElement.className = 'deck-button';
                btnElement.dataset.id = buttonId;
                btnElement.dataset.row = row;
                btnElement.dataset.col = col;

                if (button) {
                    btnElement.style.background = button.color;
                    btnElement.dataset.action = button.action.type;
                    
                    // Add icon layout class
                    if (button.icon && button.icon.layout) {
                        btnElement.classList.add(button.icon.layout);
                    }
                    
                    // Store action params for state checking
                    if (button.action.params) {
                        if (button.action.params.scene_name) {
                            btnElement.dataset.sceneName = button.action.params.scene_name;
                        }
                    }
                    
                    // Add icon if present
                    if (button.icon && button.icon.name) {
                        const iconDiv = document.createElement('div');
                        iconDiv.className = 'icon';
                        iconDiv.dataset.lucide = button.icon.name;
                        btnElement.appendChild(iconDiv);
                    }
                    
                    // Add text (unless icon-only layout)
                    if (!button.icon || button.icon.layout !== 'icon-only') {
                        const textDiv = document.createElement('div');
                        textDiv.className = 'text';
                        textDiv.textContent = button.text;
                        btnElement.appendChild(textDiv);
                    }
                    
                    // Store reference for state updates
                    this.buttonElements.set(buttonId, btnElement);
                } else {
                    btnElement.classList.add('empty');
                }

                // Enable drag-and-drop in edit mode
                if (this.editMode) {
                    if (button) {
                        btnElement.draggable = true;
                        btnElement.classList.add('draggable');
                    }
                    this.addDragListeners(btnElement);
                    
                    // In edit mode, clicking configures the button
                    btnElement.addEventListener('click', (e) => {
                        // Don't trigger if dragging
                        if (!btnElement.classList.contains('dragging')) {
                            this.showConfigModal(buttonId);
                        }
                    });
                }

                // Only handle action clicks when NOT in edit mode
                if (!this.editMode) {
                    btnElement.addEventListener('click', () => this.handleButtonClick(buttonId));
                }

                grid.appendChild(btnElement);
            }
        }
        
        // Initialize Lucide icons
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Update button states after rendering
        this.updateButtonStates();
    }

    // Drag and Drop functionality
    addDragListeners(element) {
        element.addEventListener('dragstart', (e) => this.handleDragStart(e));
        element.addEventListener('dragend', (e) => this.handleDragEnd(e));
        this.addDropListeners(element);
    }

    addDropListeners(element) {
        element.addEventListener('dragover', (e) => this.handleDragOver(e));
        element.addEventListener('dragenter', (e) => this.handleDragEnter(e));
        element.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        element.addEventListener('drop', (e) => this.handleDrop(e));
    }

    handleDragStart(e) {
        e.target.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', e.target.dataset.id);
    }

    handleDragEnd(e) {
        e.target.classList.remove('dragging');
        // Remove all drop-target highlights
        document.querySelectorAll('.drop-target').forEach(el => {
            el.classList.remove('drop-target');
        });
    }

    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    handleDragEnter(e) {
        e.preventDefault();
        if (e.target.classList.contains('deck-button') && 
            !e.target.classList.contains('dragging')) {
            e.target.classList.add('drop-target');
        }
    }

    handleDragLeave(e) {
        if (e.target.classList.contains('deck-button')) {
            e.target.classList.remove('drop-target');
        }
    }

    async handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const draggedId = e.dataTransfer.getData('text/plain');
        const targetElement = e.target.closest('.deck-button');
        
        if (!targetElement || targetElement.dataset.id === draggedId) {
            targetElement.classList.remove('drop-target');
            return;
        }
        
        const targetId = targetElement.dataset.id;
        
        // Swap buttons in config
        await this.swapButtons(draggedId, targetId);
        
        // Re-render
        this.renderDeck();
        
        // Show feedback
        console.log(`Moved button from ${draggedId} to ${targetId}`);
    }

    async swapButtons(id1, id2) {
        const button1 = this.config.buttons.find(b => b.id === id1);
        const button2 = this.config.buttons.find(b => b.id === id2);
        
        if (button1 && button2) {
            // Swap IDs
            [button1.id, button2.id] = [button2.id, button1.id];
        } else if (button1 && !button2) {
            // Moving to empty slot
            button1.id = id2;
        } else if (!button1 && button2) {
            // Moving from empty to filled (shouldn't happen, but handle it)
            button2.id = id1;
        }
        
        // Save config
        await this.saveConfig();
    }

    renderConfigView() {
        document.getElementById('grid-rows').value = this.config.grid.rows;
        document.getElementById('grid-cols').value = this.config.grid.cols;

        const buttonList = document.getElementById('button-list');
        const emptyState = document.getElementById('button-empty-state');
        
        buttonList.innerHTML = '';

        if (this.config.buttons.length === 0) {
            buttonList.style.display = 'none';
            emptyState.style.display = 'block';
            return;
        }

        buttonList.style.display = 'grid';
        emptyState.style.display = 'none';

        this.config.buttons.forEach(button => {
            const card = document.createElement('div');
            card.className = 'button-card';
            card.onclick = () => this.showConfigModal(button.id);

            card.innerHTML = `
                <div class="button-card-header">
                    <div class="button-card-id">${button.id}</div>
                    <div class="button-card-color" style="background-color: ${button.color}"></div>
                </div>
                <div class="button-card-title">${button.text}</div>
                <div class="button-card-action">${this.formatActionName(button.action.type)}</div>
            `;

            buttonList.appendChild(card);
        });
    }

    formatActionName(actionType) {
        return actionType
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    handleButtonClick(buttonId) {
        const button = this.config.buttons.find(b => b.id === buttonId);
        if (!button) return;

        this.pressButton(buttonId);
    }

    async pressButton(buttonId) {
        try {
            await window.go.main.App.PressButton(buttonId);
        } catch (error) {
            console.error('Failed to press button:', error);
        }
    }

    showConfigModal(buttonId) {
        this.currentButton = buttonId;
        const button = this.config.buttons.find(b => b.id === buttonId);

        const modal = document.getElementById('config-modal');
        const form = document.getElementById('button-config-form');
        const deleteBtn = document.getElementById('delete-btn');

        form.reset();

        if (button) {
            document.getElementById('button-text').value = button.text;
            document.getElementById('button-color').value = button.color;
            document.getElementById('action-type').value = button.action.type;
            
            // Populate icon fields
            if (button.icon && button.icon.name) {
                this.selectedIcon = button.icon.name;
                document.getElementById('button-icon').value = button.icon.name;
                document.getElementById('icon-layout').value = button.icon.layout || 'icon-above';
                
                // Find icon label
                let iconLabel = button.icon.name;
                Object.values(this.iconLibrary).forEach(categoryIcons => {
                    const icon = categoryIcons.find(i => i.name === button.icon.name);
                    if (icon) iconLabel = icon.label;
                });
                
                // Update preview
                document.getElementById('selected-icon-preview').innerHTML = `
                    <i data-lucide="${button.icon.name}"></i>
                    <span class="icon-label">${iconLabel}</span>
                `;
                document.getElementById('clear-icon-btn').style.display = 'block';
            } else {
                this.selectedIcon = null;
                document.getElementById('button-icon').value = '';
                document.getElementById('icon-layout').value = 'icon-above';
                document.getElementById('selected-icon-preview').innerHTML = `
                    <i data-lucide="image" class="icon-placeholder"></i>
                    <span class="icon-label">Choose Icon</span>
                `;
                document.getElementById('clear-icon-btn').style.display = 'none';
            }
            
            // Initialize Lucide icons for preview
            if (window.lucide) {
                lucide.createIcons();
            }
            
            this.updateActionParams(button.action.type, button.action.params);
            deleteBtn.style.display = 'block';
        } else {
            this.selectedIcon = null;
            document.getElementById('button-icon').value = '';
            document.getElementById('icon-layout').value = 'icon-above';
            document.getElementById('selected-icon-preview').innerHTML = `
                <i data-lucide="image" class="icon-placeholder"></i>
                <span class="icon-label">Choose Icon</span>
            `;
            document.getElementById('clear-icon-btn').style.display = 'none';
            deleteBtn.style.display = 'none';
            
            // Initialize Lucide icons for preview
            if (window.lucide) {
                lucide.createIcons();
            }
        }

        modal.classList.add('show');
    }

    hideConfigModal() {
        const modal = document.getElementById('config-modal');
        modal.classList.remove('show');
        this.currentButton = null;
    }

    updateActionParams(actionType, params = {}) {
        document.getElementById('scene-param').style.display = 'none';
        document.getElementById('input-param').style.display = 'none';
        document.getElementById('volume-param').style.display = 'none';
        document.getElementById('source-param').style.display = 'none';
        document.getElementById('visibility-param').style.display = 'none';
        document.getElementById('screenshot-param').style.display = 'none';

        if (actionType === 'switch_scene') {
            document.getElementById('scene-param').style.display = 'block';
            if (params.scene_name) {
                document.getElementById('scene-name').value = params.scene_name;
            }
        } else if (actionType.includes('input') || actionType.includes('mute')) {
            document.getElementById('input-param').style.display = 'block';
            if (params.input_name) {
                document.getElementById('input-name').value = params.input_name;
            }
        } else if (actionType === 'set_input_volume') {
            document.getElementById('input-param').style.display = 'block';
            document.getElementById('volume-param').style.display = 'block';
            if (params.input_name) {
                document.getElementById('input-name').value = params.input_name;
            }
            if (params.volume_db !== undefined) {
                document.getElementById('volume-db').value = params.volume_db;
            }
        } else if (actionType === 'set_source_visibility') {
            document.getElementById('source-param').style.display = 'block';
            document.getElementById('visibility-param').style.display = 'block';
            if (params.source_name) {
                document.getElementById('source-name').value = params.source_name;
            }
            if (params.visible !== undefined) {
                document.getElementById('visibility').value = params.visible.toString();
            }
        } else if (actionType === 'take_screenshot') {
            document.getElementById('source-param').style.display = 'block';
            document.getElementById('screenshot-param').style.display = 'block';
            if (params.source_name) {
                document.getElementById('source-name').value = params.source_name;
            }
            if (params.file_path) {
                document.getElementById('file-path').value = params.file_path;
            }
        }
    }

    async saveButton() {
        const form = document.getElementById('button-config-form');
        const formData = new FormData(form);

        const text = formData.get('text');
        const color = formData.get('color');
        const actionType = formData.get('action_type');
        const iconName = formData.get('icon');
        const iconLayout = formData.get('icon_layout');

        console.log('Saving button:', { text, color, actionType, iconName, iconLayout });

        if (!text || !actionType) {
            alert('Please fill in all required fields');
            return;
        }

        const params = {};
        if (actionType === 'switch_scene') {
            params.scene_name = formData.get('scene_name');
        } else if (actionType.includes('input') || actionType.includes('mute')) {
            params.input_name = formData.get('input_name');
        } else if (actionType === 'set_input_volume') {
            params.input_name = formData.get('input_name');
            params.volume_db = parseFloat(formData.get('volume_db'));
        } else if (actionType === 'set_source_visibility') {
            params.source_name = formData.get('source_name');
            params.visible = formData.get('visible') === 'true';
        } else if (actionType === 'take_screenshot') {
            params.source_name = formData.get('source_name');
            params.file_path = formData.get('file_path');
        }

        const [, row, col] = this.currentButton.split('-').map(Number);

        const button = {
            id: this.currentButton,
            row: row,
            col: col,
            text: text,
            color: color,
            action: {
                type: actionType,
                params: params
            }
        };
        
        // Add icon data if icon is selected
        if (iconName && iconName !== '') {
            button.icon = {
                name: iconName,
                layout: iconLayout || 'icon-above'
            };
        }

        console.log('Button to save:', button);

        try {
            await window.go.main.App.SaveButton(JSON.stringify(button));
            await this.loadConfig();
            this.renderDeck();
            this.renderConfigView();
            this.hideConfigModal();
            console.log('Button saved successfully');
        } catch (error) {
            console.error('Failed to save button:', error);
            alert('Failed to save button: ' + error.message);
        }
    }
        }
    }

    async deleteButton() {
        if (!confirm('Are you sure you want to delete this button?')) {
            return;
        }

        try {
            await window.go.main.App.DeleteButton(this.currentButton);
            await this.loadConfig();
            this.renderDeck();
            this.renderConfigView();
            this.hideConfigModal();
        } catch (error) {
            console.error('Failed to delete button:', error);
        }
    }

    // Edit Mode Methods
    toggleEditMode() {
        this.editMode = !this.editMode;
        const btn = document.getElementById('edit-mode-toggle');
        const text = document.getElementById('edit-mode-text');
        
        if (this.editMode) {
            btn.classList.add('active');
            text.textContent = 'Edit Mode: ON';
        } else {
            btn.classList.remove('active');
            text.textContent = 'Edit Mode';
        }
        
        // Re-render deck to apply drag-and-drop
        this.renderDeck();
        console.log('Edit mode:', this.editMode ? 'ON' : 'OFF');
    }

    // Icon Picker Methods
    showIconPicker() {
        const modal = document.getElementById('icon-picker-modal');
        modal.classList.add('show');
        
        // Populate icon grid
        this.populateIconGrid('all');
        
        // Setup tab switching
        const tabs = document.querySelectorAll('.tab-btn');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                this.populateIconGrid(tab.dataset.category);
            });
        });
    }

    hideIconPicker() {
        const modal = document.getElementById('icon-picker-modal');
        modal.classList.remove('show');
    }

    populateIconGrid(category) {
        const grid = document.getElementById('icon-picker-grid');
        grid.innerHTML = '';
        
        let iconsToShow = [];
        
        if (category === 'all') {
            // Show all icons
            Object.values(this.iconLibrary).forEach(categoryIcons => {
                iconsToShow.push(...categoryIcons);
            });
        } else {
            // Show category icons
            iconsToShow = this.iconLibrary[category] || [];
        }
        
        iconsToShow.forEach(icon => {
            const iconOption = document.createElement('div');
            iconOption.className = 'icon-option';
            iconOption.dataset.iconName = icon.name;
            
            if (this.selectedIcon === icon.name) {
                iconOption.classList.add('selected');
            }
            
            iconOption.innerHTML = `
                <i data-lucide="${icon.name}"></i>
                <div class="icon-option-name">${icon.label}</div>
            `;
            
            iconOption.addEventListener('click', () => {
                this.selectIcon(icon.name, icon.label);
            });
            
            grid.appendChild(iconOption);
        });
        
        // Initialize Lucide icons
        if (window.lucide) {
            lucide.createIcons();
        }
    }

    selectIcon(iconName, iconLabel) {
        this.selectedIcon = iconName;
        
        // Update hidden input
        document.getElementById('button-icon').value = iconName;
        
        // Update preview
        const preview = document.getElementById('selected-icon-preview');
        preview.innerHTML = `
            <i data-lucide="${iconName}"></i>
            <span class="icon-label">${iconLabel}</span>
        `;
        
        // Show clear button
        document.getElementById('clear-icon-btn').style.display = 'block';
        
        // Initialize Lucide icons
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Close picker
        this.hideIconPicker();
        
        console.log('Selected icon:', iconName);
    }

    clearSelectedIcon() {
        this.selectedIcon = null;
        document.getElementById('button-icon').value = '';
        document.getElementById('selected-icon-preview').innerHTML = `
            <i data-lucide="image" class="icon-placeholder"></i>
            <span class="icon-label">Choose Icon</span>
        `;
        document.getElementById('clear-icon-btn').style.display = 'none';
        
        // Initialize Lucide icons
        if (window.lucide) {
            lucide.createIcons();
        }
    }

    async updateGrid() {
        const rows = parseInt(document.getElementById('grid-rows').value);
        const cols = parseInt(document.getElementById('grid-cols').value);

        if (rows < 1 || rows > 10 || cols < 1 || cols > 10) {
            alert('Rows and columns must be between 1 and 10');
            return;
        }

        try {
            await window.go.main.App.UpdateGrid(rows, cols);
            await this.loadConfig();
            this.renderDeck();
            this.renderConfigView();
        } catch (error) {
            console.error('Failed to update grid:', error);
        }
    }

    async updateServerURL() {
        const url = document.getElementById('server-url').value;
        if (!url) {
            alert('Please enter a server URL');
            return;
        }

        try {
            await window.go.main.App.SetServerURL(url);
            alert('Server URL updated successfully');
        } catch (error) {
            console.error('Failed to update server URL:', error);
            alert('Failed to update server URL');
        }
    }

    switchView(view) {
        const deckView = document.getElementById('deck-view');
        const configView = document.getElementById('config-view');

        if (view === 'config') {
            deckView.classList.add('hidden');
            configView.classList.add('active');
            this.renderConfigView();
            this.currentView = 'config';
        } else {
            deckView.classList.remove('hidden');
            configView.classList.remove('active');
            this.currentView = 'deck';
        }
    }

    async toggleFullscreen() {
        try {
            await window.go.main.App.ToggleFullscreen();
        } catch (error) {
            console.error('Failed to toggle fullscreen:', error);
        }
    }

    setupEventListeners() {
        // Edit mode toggle
        const editModeBtn = document.getElementById('edit-mode-toggle');
        if (editModeBtn) {
            editModeBtn.addEventListener('click', () => {
                this.toggleEditMode();
            });
        }

        // Configure button
        const configureBtn = document.getElementById('configure-btn');
        if (configureBtn) {
            configureBtn.addEventListener('click', () => {
                this.switchView('config');
            });
        }

        // View switching
        document.getElementById('btn-configure').addEventListener('click', () => {
            this.switchView('config');
        });

        document.getElementById('btn-back-to-deck').addEventListener('click', () => {
            this.switchView('deck');
        }); 

        // Fullscreen
        document.getElementById('btn-fullscreen').addEventListener('click', () => {
            this.toggleFullscreen();
        });

        // Grid configuration
        document.getElementById('btn-update-grid').addEventListener('click', () => {
            this.updateGrid();
        });

        // Server configuration
        document.getElementById('btn-update-server').addEventListener('click', () => {
            this.updateServerURL();
        });

        // Add button
        document.getElementById('btn-add-button').addEventListener('click', () => {
            for (let row = 0; row < this.config.grid.rows; row++) {
                for (let col = 0; col < this.config.grid.cols; col++) {
                    const buttonId = `btn-${row}-${col}`;
                    if (!this.config.buttons.find(b => b.id === buttonId)) {
                        this.showConfigModal(buttonId);
                        return;
                    }
                }
            }
            alert('Grid is full! Increase grid size or delete a button.');
        });

        // Icon picker
        const iconPickerBtn = document.getElementById('icon-picker-btn');
        if (iconPickerBtn) {
            iconPickerBtn.addEventListener('click', () => {
                this.showIconPicker();
            });
        }

        const clearIconBtn = document.getElementById('clear-icon-btn');
        if (clearIconBtn) {
            clearIconBtn.addEventListener('click', () => {
                this.clearSelectedIcon();
            });
        }

        const iconPickerClose = document.getElementById('icon-picker-close');
        if (iconPickerClose) {
            iconPickerClose.addEventListener('click', () => {
                this.hideIconPicker();
            });
        }

        // Close icon picker on background click
        document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
            if (e.target.id === 'icon-picker-modal') {
                this.hideIconPicker();
            }
        });

        // Modal form
        document.getElementById('button-config-form').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveButton();
        });

        document.getElementById('cancel-btn').addEventListener('click', () => {
            this.hideConfigModal();
        });

        document.getElementById('delete-btn').addEventListener('click', () => {
            this.deleteButton();
        });

        // Action type change
        document.getElementById('action-type').addEventListener('change', (e) => {
            this.updateActionParams(e.target.value);
        });

        // Close modal on background click
        document.getElementById('config-modal').addEventListener('click', (e) => {
            if (e.target.id === 'config-modal') {
                this.hideConfigModal();
            }
        });
    }

    async updateStatus() {
        try {
            const status = await window.go.main.App.GetStatus();
            this.updateStatusDisplay(status);
        } catch (error) {
            console.error('Failed to get status:', error);
        }
    }

    updateStatusDisplay(status) {
        // Update button states based on status
        this.currentStatus = status;
        this.updateButtonStates();
    }
    
    updateButtonStates() {
        if (!this.buttonElements || !this.currentStatus) return;
        
        // Iterate through all button elements
        this.buttonElements.forEach((btnElement, buttonId) => {
            const action = btnElement.dataset.action;
            
            // Remove active class first
            btnElement.classList.remove('active');
            
            // Check for active state based on action type
            if (action === 'toggle_stream' || action === 'start_stream' || action === 'stop_stream') {
                if (this.currentStatus.streaming) {
                    btnElement.classList.add('active');
                }
            } else if (action === 'toggle_record' || action === 'start_record' || action === 'stop_record') {
                if (this.currentStatus.recording) {
                    btnElement.classList.add('active');
                }
            } else if (action === 'switch_scene') {
                // Check if this button's scene matches current scene
                const sceneName = btnElement.dataset.sceneName;
                if (sceneName && this.currentStatus.current_scene === sceneName) {
                    btnElement.classList.add('active');
                }
            }
        });
    }
}

// Initialize the deck when ready
new StreamPiDeck();
